// Copyright (c) 2022 The ZMK Contributors
// SPDX-License-Identifier: MIT

#include <behaviors.dtsi>
#include <dt-bindings/zmk/keys.h>
#include <dt-bindings/zmk/bt.h>
#include <dt-bindings/zmk/dynamic-macros.h>

#define XXX &none
#define ___ &trans

#define BASE 0
#define NUM 1
#define SYM 2
#define UTIL 3

#define MO(LAYER) &mo_tap LAYER F24

// Keep sticky keys active for a long time so they effectively do not time out
#define STICKY_KEY_TIMEOUT 60000

#define ZMK_HELPER_STRINGIFY(x) #x

/* ZMK_BEHAVIOR */

#define ZMK_BEHAVIOR_CORE_caps_word      compatible = "zmk,behavior-caps-word";      #binding-cells = <0>
#define ZMK_BEHAVIOR_CORE_hold_tap       compatible = "zmk,behavior-hold-tap";       #binding-cells = <2>
#define ZMK_BEHAVIOR_CORE_key_repeat     compatible = "zmk,behavior-key-repeat";     #binding-cells = <0>
#define ZMK_BEHAVIOR_CORE_macro          compatible = "zmk,behavior-macro";          #binding-cells = <0>
#define ZMK_BEHAVIOR_CORE_dynamic_macro  compatible = "zmk,behavior-dynamic-macro";  #binding-cells = <1>
#define ZMK_BEHAVIOR_CORE_mod_morph      compatible = "zmk,behavior-mod-morph";      #binding-cells = <0>
#define ZMK_BEHAVIOR_CORE_sticky_key     compatible = "zmk,behavior-sticky-key";     #binding-cells = <1>
#define ZMK_BEHAVIOR_CORE_tap_dance      compatible = "zmk,behavior-tap-dance";      #binding-cells = <0>
#define ZMK_BEHAVIOR_CORE_tri_state      compatible = "zmk,behavior-tri-state";      #binding-cells = <0>

#define ZMK_BEHAVIOR(name, type, ...) \
    / { \
        behaviors { \
            name: name { \
                label = ZMK_HELPER_STRINGIFY(ZB_ ## name); \
                ZMK_BEHAVIOR_CORE_ ## type; \
                __VA_ARGS__ \
            }; \
        }; \
    };

&caps_word {  
    /delete-property/ ignore-modifiers; // mods deactivate, requires PR #1451
    /delete-property/ ignore-numbers;
    continue-list = <BACKSPACE ENTER DELETE UNDERSCORE MINUS>;
};
&num_word { 
    layers = <NUM>; // requires PR #1441
    continue-list = <BACKSPACE ENTER DELETE UNDERSCORE MINUS PLUS ASTRK EQUAL FSLH DOT LPAR RPAR HASH DLLR PRCNT CARET LEFT RIGHT UP DOWN>;
};

&key_repeat {
    usage-pages = <HID_USAGE_KEY HID_USAGE_CONSUMER>; // repeat all keys
};

// Alt+Tab swapper, requires PR #1366
ZMK_BEHAVIOR(swapper, tri_state,
    bindings = <&kt LALT>, <&kp TAB>, <&kt LALT>;
    ignored-key-positions = <LM1>; // shift-alt-tab 
)

&sk { // sticky-key
    release-after-ms = <3000>;  // release after timeout
    quick-release;              // no double capitalization when rolling ke
    ignore-modifiers;
    lazy;
};
ZMK_BEHAVIOR(sk_no_lazy, sticky_key, // sticky-key without lazy
    bindings = <&kp>;
    release-after-ms = <3000>;  // release after timeout
    quick-release;              // no double capitalization when rolling keys
    ignore-modifiers;
)
&sl { // sticky-layer 
    release-after-ms = <500>;  // release after timeout
    // This is useful for enabling a layer and then pressing a bunch of sticky keys without leaving the layer. 
    // However, this breaks tapping sl+control+key because it does not exit the layer.
    // ignore-modifiers;
};

// all sticky keys are sticky when tapped, but momentary when held. 
// this allows for rolling layer keys, and accessing modifiers on base, while not getting in the way.
// this behavior is especially useful for use with a mouse because sticky odifiers don't linger
#define STICKY_TAP_MS 200

// tap: sticky-mod | hold: mod
#define SK(mod) &sk_mod mod mod
ZMK_BEHAVIOR(sk_mod, hold_tap,
    flavor = "balanced"; // balanced because we want to consider as tap when rolling
    tapping-term-ms = <STICKY_TAP_MS>; 
    bindings = <&kp>, <&sk>; 
    hold-while-undecided; // requires pr
)
// for GUI/ALT, we don't want to trigger a tap, so we disable hold while undecided
#define SK_LGUI &sk_mod_gui LGUI LGUI 
#define SK_LALT &sk_mod_gui LALT LALT 
ZMK_BEHAVIOR(sk_mod_gui, hold_tap,
    flavor = "balanced"; // balanced because we want to consider as tap when rolling
    tapping-term-ms = <STICKY_TAP_MS>; 
    bindings = <&kp>, <&sk>; 
)

// tap: sticky-shift | hold: shift | shift + tap / double-tap: caps-word 
#define SK_SHFT &sk_shft LSFT LSFT
ZMK_BEHAVIOR(sk_shft, hold_tap,
    flavor = "balanced"; 
    tapping-term-ms = <STICKY_TAP_MS>; 
    bindings = <&kp>, <&smrt_shft_morph>; 
    hold-while-undecided;
) 
ZMK_BEHAVIOR(smrt_shft_morph, mod_morph,
    mods = <(MOD_LSFT)>; // shift + tap: caps word
    bindings = <&sk_no_lazy LSFT>, <&caps_word>; 
) 

// tap: sticky-layer | hold: layer
#define SMRT_SYM &smrt_layer SYM SYM
#define SMRT_FUN &smrt_layer FUN FUN
ZMK_BEHAVIOR(smrt_layer, hold_tap,
    flavor = "hold-preferred"; // in most cases we want to avoid taps
    tapping-term-ms = <STICKY_TAP_MS>; 
    bindings = <&mo>, <&sl>; 
) 

// tap: sticky-num | hold: num | double-tap: num-word | triple-tap: num-lock
#define SMRT_NUM &smrt_num NUM NUM
ZMK_BEHAVIOR(smrt_num, hold_tap,
    flavor = "hold-preferred"; 
    tapping-term-ms = <STICKY_TAP_MS>; 
    bindings = <&mo>, <&num_dance>; 
) 
ZMK_BEHAVIOR(num_dance, tap_dance,
    tapping-term-ms = <300>; 
    bindings = <&sl NUM>, <&num_word>, <&tog NUM>; // todo: to or tog?
)

#define S_UNDO &kp C_AC_UNDO
#define S_CUT &kp C_AC_CUT
#define S_COPY &kp C_AC_COPY
#define S_PASTE &kp C_AC_PASTE
#define S_REDO &kp C_AC_REDO

/ {
    behaviors {
        ht: hold_tap {
            label = "hold_tap";
            compatible = "zmk,behavior-hold-tap";
            #binding-cells = <2>;
            flavor = "tap-preferred";
            tapping-term-ms = <220>;
            quick-tap-ms = <150>;
            global-quick-tap;
            bindings = <&kp>, <&kp>;
        };
        nk: not_so_sticky_key {
            compatible = "zmk,behavior-hold-tap";
            label = "NOT_SO_STICKY_KEY";
            #binding-cells = <2>;
            tapping_term_ms = <200>;
            flavor = "tap-preferred";
            bindings = <&kp>, <&sk>;
        };
        skq: sticky_key_quick_release {
            compatible = "zmk,behavior-sticky-key";
            label = "STICKY_KEY_QUICK_RELEASE";
            #binding-cells = <1>;
            bindings = <&kp>;
            quick-release;
            release-after-ms = <STICKY_KEY_TIMEOUT>;
        };
        // A hold-tap that activates without delay (like `&mo`)
        mo_tap: mo_with_tap {
          compatible = "zmk,behavior-hold-tap";
          label = "MO_WITH_TAP";
          #binding-cells = <2>;
          tapping_term_ms = <0>;
          retro-tap;
          flavor = "hold-preferred";
          bindings = <&mo>, <&kp>;
        };
    };

    conditional_layers {
        compatible = "zmk,conditional-layers";
        tri_layer {
            if-layers = <1 2>;
            then-layer = <3>;
        };
    };
    macros {
        right_arrow: right_arrow {
            label = "ZM_right_arrow";
            compatible = "zmk,behavior-macro";
            #binding-cells = <0>;
            bindings
                = <&macro_tap &kp MINUS &kp GT>
                ;
        };
    };
    combos {
        compatible = "zmk,combos";
        combo_eq {
            timeout-ms = <30>;
            key-positions = <2 3>;
            bindings = <&kp EQUAL>;
        };
        combo_right_arrow {
            timeout-ms = <30>;
            key-positions = <7 8>;
            bindings = <&right_arrow>;
        };
    };
    
    

    keymap {
        compatible = "zmk,keymap";
        default_layer {
            bindings = <
            &kp W      &kp L      &kp Y      &kp P      &kp B          &kp Z      &kp F      &kp O      &kp U      &kp SQT
            &kp C       &kp R      &kp S       &kp T     &kp G          &kp M      &kp N       &kp E     &kp I       &kp A
            &kp Q      &kp J      &kp V      &kp D      &kp K          &kp X      &kp H      &kp FSLH  &kp COMMA    &kp DOT
                                             MO(NUM)   &kp SPACE     &kp LSHIFT  MO(SYM)
            >;
        };

        left_layer {
            bindings = <
        
                                 &swapper  &kp HASH  &kp DLLR  &kp PRCNT   &kp CARET       &kp PLUS   &kp N7     &kp N8     &kp N9    &kp ASTRK
         
            SK(LCTRL) SK(LALT)  SK(LCMD)  SK(LSHFT)  &kp LC(F)       &kp EQUAL     &kp N0    &kp N1    &kp N2     &kp N3
      
                                S_UNDO  S_CUT  S_COPY  S_PASTE  S_REDO      &kp MINUS   &kp N4     &kp N5     &kp N6     &kp DOT
    
                                                                    &trans     &trans       &trans     &trans
        
            >;
        };

        right_layer {
            bindings = <
        
            &kp GRAVE  &kp AMPS   &kp PIPE   &kp LBKT   &kp RBKT        &kp HOME  &kp PG_DN  &kp PG_UP   &kp END   &kp ESC
        
            &kp BSLH   &kp SEMI  &kp COLON   &kp LPAR   &kp RPAR         &kp LEFT  &kp DOWN   &kp UP     &kp RIGHT   &kp ENTER
       
            &kp TILDE  &kp EXCL     &kp AT  &kp LBRC   &kp RBRC         &bt BT_CLR   &kp BSPC   &kp DEL    &kp TAB   &kp UNDER
       
                                             &trans     &trans         &trans     &trans
        
            >;
        };

        tri_layer {
            bindings = <
            &kp LC(A) &kp C_MUTE &kp C_VOL_DN &kp C_VOL_UP &bootloader                &kp HOME  &kp PG_DN  &kp PG_UP   &kp END   &kp ESC
            SK(LCTRL) SK(LALT)  SK(LCMD)  SK(LSHFT)  &kp LC(F)                          &kp LEFT  &kp DOWN   &kp UP     &kp RIGHT   &kp ENTER
            S_UNDO  S_CUT  S_COPY  S_PASTE  S_REDO                   &bt BT_NXT   &kp BSPC   &kp DEL    &kp TAB   &kp UNDER
                                             &trans     &trans                        &trans     &trans
            >;
        };
    };
};
